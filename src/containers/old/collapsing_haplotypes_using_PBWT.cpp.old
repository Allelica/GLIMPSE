////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2018 Olivier Delaneau, University of Lausanne
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
////////////////////////////////////////////////////////////////////////////////
#include <containers/haplotype_set.h>
#include <tuple>

haplotype_set::haplotype_set() {
	n_site = 0;
	n_hap = 0;
}

haplotype_set::~haplotype_set() {
	n_site = 0;
	n_hap = 0;
}

void haplotype_set::buildPBWTgraph(variant_map & V, int K, double maf) {
	tac.clock();

	vrb.title("Collapse reference set of haplotypes ...");

	//Classify variants
	for (int l = 0 ; l < n_site ; l ++) {
		double cmaf = V.vec_pos[l]->calt * 1.0 / (V.vec_pos[l]->cref + V.vec_pos[l]->calt);
		if (cmaf > 0.5) cmaf = 1.0 - cmaf;
		if (cmaf >= maf) {
			pbwt_variants.push_back(l);
			pbwt_flags.push_back(true);
		} else pbwt_flags.push_back(false);
	}
	vrb.bullet("MAF filtering (all=" + stb.str(n_site) + " / kept = " + stb.str(pbwt_variants.size()) + ")");

	//Build PBWT structures
	pbwt_arrays = vector < vector < int > > (pbwt_variants.size(), vector < int > (n_hap, 0));
	pbwt_divergences = vector < vector < int > > (pbwt_variants.size(), vector < int > (n_hap, 0));
	vector < int > A = vector < int >(n_hap, 0);
	vector < int > B = vector < int >(n_hap, 0);
	for (int l = 0 ; l < pbwt_variants.size() ; l ++) {
		int u = 0, v = 0, p = l, q = l;

		for (int h = 0 ; h < n_hap ; h ++) {
			int alookup = l?pbwt_arrays[l-1][h]:h;
			int dlookup = l?pbwt_divergences[l-1][h]:-1;
			if (dlookup > p) p = dlookup;
			if (dlookup > q) q = dlookup;
			if (!H_opt_var.get(pbwt_variants[l],alookup)) {
				pbwt_arrays[l][u] = alookup;
				pbwt_divergences[l][u] = p;
				p = -1; u++;
			} else {
				A[v] = alookup;
				B[v] = q;
				q = -1; v++;
			}
		}
		std::copy(A.begin(), A.begin()+v, pbwt_arrays[l].begin()+u);
		std::copy(B.begin(), B.begin()+v, pbwt_divergences[l].begin()+u);
	}
	vrb.bullet("PBWT finished");

	//Segmentation
	bool done = false;
	priority_queue < tuple < int, int, int > > S;
	do {
		if (S.empty()) {
			int start = 0;
			int end = pbwt_variants.size() - 1;
			int count = getNumberOfDistinctHaplotypesInWindow(end, start);
			//cout << "I " << start << " " << end << " " << count << endl;
			S.push(std::make_tuple(count, start, end));
			done=(count<=K);
		} else if (get<0>(S.top()) > K) {
			int start0 = get<1>(S.top());
			int end1 = get<2>(S.top());
			int size = end1 - start0 + 1;
			int end0 = start0 + size / 2;
			int start1 = end0 + 1;
			int count0 = getNumberOfDistinctHaplotypesInWindow(end0, start0);
			int count1 = getNumberOfDistinctHaplotypesInWindow(end1, start1);
			//cout << "N " << start0 << " " << end0 << " " << count0 << "\t" << start1 << " " << end1 << " " << count1 << endl;
			//int tmp;
			//cin >> tmp;
			S.pop();
			S.push(std::make_tuple(count0, start0, end0));
			S.push(std::make_tuple(count1, start1, end1));
		} else done = true;
	} while (!done);
	vrb.bullet("Optimal finished (n=" + stb.str(S.size()) + " / l=" + stb.str(pbwt_variants.size() *1.0 / S.size()) + ")");

	//Pack up & fill up in vector
	set < tuple < int, int, int > > S1;
	while (!S.empty()) {
		S1.insert(make_tuple(get<1>(S.top()), get<2>(S.top()), get<0>(S.top())));
		S.pop();
	}
	vector < tuple < int, int, int, int, int > > S2;
	for(set < tuple < int, int, int > > :: iterator it = S1.begin() ; it != S1.end() ; it ++) {
		S2.push_back(make_tuple(get<0>(*it), get<1>(*it), 0, 0, get<2>(*it)));
	}
	get<2>(S2[0]) = 0;
	get<3>(S2.back()) = n_site-1;
	for (int e = 1 ; e < S2.size() ; e ++) {
		int p0 = pbwt_variants[get<1>(S2[e-1])];
		int p1 = pbwt_variants[get<0>(S2[e-0])];
		int nvar = p1 - p0 - 1;
		get<3>(S2[e-1]) = p0 + nvar/2;
		get<2>(S2[e-0]) = p0 + nvar/2 + 1;
	}

	//
	vector < vector < float > > Hap = vector < vector < float > > (S2.size());
	vector < vector < float > > Frq = vector < vector < float > > (S2.size());
	for (int e = 0 ; e < S2.size() ; e ++) {
		int N = get<3>(S2[e]) - get<2>(S2[e]) + 1;
		int K = get<4>(S2[e]), k = 0;

		Hap[e] = vector < float > (N * K, 0.0);
		Frq[e] = vector < float > (K, 0.0);
		for (int h = 0 ; h < n_hap ; h++) {
			if (h >0 && pbwt_divergences[get<1>(S2[e])][h] >= get<0>(S2[e])) k++;
			Frq[e][k] ++;
			for (int al = get<2>(S2[e]) ; al <= get<3>(S2[e]) ; al ++) Hap[e][k * N + (al - get<2>(S2[e]))] += H_opt_var.get(al,pbwt_arrays[get<1>(S2[e])][h]);
		}
		if (k+1 != K) {
			cout << "ERROR " << K << " " << k << endl;
			exit(0);
		}
	}

	for (int e = 0 ; e < S2.size() ; e ++) {
		int N = get<3>(S2[e]) - get<2>(S2[e]) + 1;
		int K = get<4>(S2[e]);
		for (int k = 0 ; k  < K ; k ++)
			for (int l = 0 ; l < N ; l ++)
				Hap[e][k*N + l] /= Frq[e][k];
	}


	for (int e = 0 ; e < S2.size() ; e ++) {
		int N = get<3>(S2[e]) - get<2>(S2[e]) + 1;
		int K = get<4>(S2[e]);
		cout << endl << "BLOC " << e << " = " << N << " " << K << " ------------------------------------------- " << endl;

		for (int k = 0 ; k  < K ; k ++) {
			cout << Frq[e][k] << " /";
			for (int l = 0 ; l < N ; l ++) cout << " " << Hap[e][k*N + l];
			cout << endl;
		}
	}


	vrb.bullet("PBWT initialization (" + stb.str(tac.rel_time()*1.0/1000, 2) + "s)");
}
